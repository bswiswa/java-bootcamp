What is Java?
-general purpose, object oriented, platform independent, concurrent and very fast programming language.
-invented in the mid 90s. Similar to C & C++
-simplicity was the goal. Java has automatic memory management using garbage collection. No manual memory management like C or C++
-secure

Goals during creation
- low memory consumption
- should allow devices to commuicate
- should be independent of platforms - run on target device with no issues
- should be secure
- should support multithreading so that devices can perform other tasks
C++ was limited due to lack of platform independence
James Gosling created Oak then renamed Java. It was too advanced and rejected by cable companies.
HotJava browser created by Sun which made internet interactions more dynamic by embedding Java programs
First version released in 1996.

Compilation
- verify syntax & semantics of source code
- optimize code
- generates machine code

Platform dependency
-If processor differs, the software has to be recompiled in order to run

Interpreter
No compiling. Interpreter handles source code and produces results
Compiler path: source code -> compiler -> machine code -> CPU -> results
Interpreter path: source code -> interpreter -> results
Interpreter is a virtual machine that simulates a CPU. 
Fetch & Execute cycle:
      CPU		<- Memory	<- Storage
      (executes)	-> data

Interpreter also fetches instructions from memory. It understands the statement then executes precompiled machine code in its library.
As long as a platform has an interpreter suitable for it, code will be made once and run anywhere
Pros of interpreter:
     platform independence
     no compilation step
     easier to update due to no compilation
Limitations of intepreter
	    Slow due to costly memory access. Registers make compiled 
	    languages much faster
	    Source code is reinterpreted every time
	    Interpreter is loaded into memory

Java Intepretation
     source code -> Java Compiler -> Java byte code(platform independent intermediate) -> JVM (Java virtual machine, dependent on machine) -> results

eg Hello.java (source) -> javac Hello.java [compilation] -> Hello.class (Java byte code) -> Hello.class can now be executed on any platform with JVM via java Hello

Java Speed?
How is it fast if interpretation is slow?
- Bytecode interpretations are much faster because Java bytecode is
  compact, compiled and optimized already. Java Bytecode's compactness also
  allows quick transfer across networks. Remember that Java was designed to work with multiple types of devices on a network
- Just-in-time compilation (JIT) - monitors frequently executed bytecodes "hotspots". These hotspots are converted to machine code and cached. This cached machine code is executed faster later from the cache. This is called dynamic compilation. The caching gives Java its speed

Java Virtual Machine
- the cornerstone of Java
- is an abstract computing machine
- executes instruction set (Java bytecode)
- manipulates memory at runtime
- is secure across networks
Abstract JVM specification

Java Software Family
Java Standard Edition(Java SE)
     standalone applications for desktops & servers
Java Enterprise Edition (Java EE)
     enterprise applications for servers eg e-comerce websites
     includes Java SE
Java Micro Edition (Java ME)
     applications for resource-constrained devices

Java SE 
Java Runtime Environment
     	  only run Java programs
Java Development Kit (JDK)
	  develop & run Java programs

Java program structure
     CLASS
     variable declarations
     constructors, statements
     methods
     nested classes, statements

if you have a class with the modifier public, then the name of the file has to be the same as that class name

main method is invoked first when the Java Virtual Machine (JVM) loads the class bytecodes.
It must be declared as 
   public - for JVM to be able to invoke it. otherwise it will not run. public means that you can call the method from outside of the class you are currently in. This is necessary because this method is being called by the Java runtime system which is not located in your current class.
   static - access modifier which allows us to call this method directly using the class name without creating an object of it. So every function in a class that only performs tasks in it should be static eg static int add_num
   void - return values mean different things on different platforms. Java is avoiding that problem by having its main method return nothing. There are other ways to exit the program eg System.exit()

Classes & Objects
OOP roots back to 1960s. Conceived to implement large projects and implement
real world scenarios in a natural way

Classes are blueprints and objects are instances of objects
Class members - variables, methods, member classes, member interfaces

class Student{
//variable declarations

//method declarations
}

to initialize an object we use the new key word
the dot operator is used to access the object's state and methods

Java Basics
     comments //ignore rest of line /*ignore block*/
     case-sensitive Test != test
     classes, methods and varialbles must start with letter, underscore or $
     some reserved keywords like class, interface, enum...
     Printing to console
     	      System.out.println(string) - print and go to new line
	      System.out.print(string) - print and place cursor after the printed string.

Variables
	containers of data or references to objects.
	always have a type associated with it and they will hold data of that type
	variable type also determines the methods that can be performed on that type. 
	Variable type is declared when the object is created. It cannot be changed thereafter. Thus Java is a statically-typed language. There is static type checking to prevent assigning a type that is not the original type.
	Dynamically typed languages allow variables to change their types at any point eg JavaScript
	Static type checking has the advantage that it allows earlier detection of programming mistakes.
	Variable declaration <type> <name> = [literal or expression]
	Variable is something whose value can be changed
Variable Kinds
	 instance variables or attributes - declared directly in the body of the clas. If not initialized they always have a default value. They represent state specific to each object of a class. Cannot be reinitialized directly within a class. Reinitialization is done within object methods only
	 static variables - declared in class with keyword static. Is shared by all objects in that class. Only one copy is maintained per class regardless of the number of objects of class. Also get default value and cannot be reinitialized directly within the class.
	 local variables - declared in methods. Includes method parameters. Not accessible outside of the method. They only exist on the stack when the method is mounted and they are cleared off after its execution. No need for default value.

Variable types
	 Primitive
	 8 types - boolean, byte, short, int, long, float, double, char (char is internally represented as an unsigned int)
	   integers
		whole or fixed point numbers - byte, short, int, long
		represented by signed two's complement.
		Binary addition:
		Sign-magnitude representation of bits makes the left-most
		bit 1 for negative and 0 for positive. There are however
		two problems associated with this representation
		1. There are two representations of zero eg for 8 bits -
		1000 0000 and 0000 0000 are -0 and +0
		2. Binary addition of positive and negative numbers doesn't
		work - eg add 16 [ 0001 0000 ] to -24 [ 1001 1000 ] = 
		1010 1000 or -40
		In order to make binary addition work, we need a way to find
		a number which when added to another binary number results
		in 0000 0000 (in a 8 bits for example). In other words for
		every bit pattern of N bits there is a corresponding bit 
		pattern of N bits which produces an N-bit zero when the two
		patterns are used as operands for the binary addition
		algorithm. Each pattern can be thought of representing the
		negative of the number that is represented by the other 
		pattern.
		This representation is called two's complement. It is 
		derived as follows: 
		1. Start with an N-bit representation of an integer
		2. To calculate the N-bit representation of the negative
		integer, reflect each bit of the bit pattern
		(change 0 to 1 and 1 to 0)
		3. Add one.

		integers represent whole or fixed-point numbers
		types: byte(8 bit)[-128 to +127], short(16 bit)[-32768 to 32767 (~32 000)], int(32 bit) [-2147483648 to 2147483647 (~2 billion)], long(64bit)
		default of all ints is 0 for class-level variables, however within methods, they need to be initialized before use
		long = 10000000L // L required if above the int range
		int also stores hexadecimal numbers or Java 7 binary or octals. Underscores can be used in between digits to improve readability eg int x = 1_243_300;
Floatng-Point Numbers
real numbers with 32 bit float or 64-bit double
   double is more precise
   Data representation ~ 32 and 64 bit IEEE 754 flaating point convention
   float -3.4E38 to 3.4E38 where E is power 10
   double -1.7E308 to 1.7E308
   float f = 123.4f //TRAILING F is required (upper or lower case)
   double d = 123.4 //TRAILING D is optional

   General rule - avoid float and double if exact answers are required. Unsuitable for money calculations. Recommended to use BigDecimal which comes in Java library. You can use int or long but you have to keep track of decimal point yourself.
Floating point arithmetic is not as fast as integer. In general stick with int and double. double's greater precision is useful. Use float if memery saving is important.

Characters
represented by 16 bit unsigned integers internally
range is 0 to 2^16 -1 (since we are not dealing with negative numbers)
default value is '\u0000' a unicode hexadecimal escape sequence
Java uses 16 bit unicode scheme (UTF-16) which means that they are first encoded in UTF-16 format (a hexadecimal number) then stored as a 16 bit unsigned int.UTF is one of the implementations of the unicode standards.
eg 'A' is encoded to hexadecimal 0041 which is then stored as a 16 bit unsigned int 00000000 01000001
   char c = 'A'; // always in single quotes
   char c = 65; // can also be declared with an unsigned int. It will be assigned the UTF-16 character corresponding to 65. thus we can add to char variables just like we do with ints
   char c = '\u0041'; // assigned with a hexadecimal unicode number. Useful if keyboard doesn't allow us to assign certain characters.
   char c = 0x41; // hexadecimal converted to decimal number and character corresponding to that UTF number is assigned.

Boolean
Boolean bit storage is JVM specific/ machine specific. Has value of true or \
false. Default value is false;

Type Casting
Assign variable or literal of one data type to another type eg change a byte to an int or long to int. It is only available for numeric to numeric casting. Since an character is stored as an unsigned int, it can also be typecasted. Cannot cast to boolean or viceversa.
Implicit typecasting:
	 smaller to larger type conversion - widening conversion
	 eg int x = 65; long y = x; (implicit casting by compiler)
	 assigning an int to a float is implicit. As long as range of values of the final type is larger than the input type, casting is implicit eg long int to float is implicit. So assigning char to int is implicit.

Explicit typecasting
	 when assigning a variable of larger range to a smaller range type = narrowing conversion. note that even though char and short are both 16 bits, char has a larger positive range.
	 long y = 42;
	 int x = (int)y;
	 without the above cast we would get a compiler error due to the different type.

* althogh implicit casting is taken care of by the compiler, you can still explicitly cast.
Out of range assignments result in information loss
    eg byte narrowByte = (byte)123456; // narrowByte = 64 (only lowest rightmost 8 bits are saved)
Truncation
Floating-point to int/char will always truncate the number
	       eg int x = (int)3.14f; // x = 3;
	       	  int y = (int)0.9; // y = 0;
		  char c = (char) 65.5; y = 'A'

Information Loss Implicit Casting
Assigning int to float or long to float can result in loss of precision. Assigning long to double results in loss as well.
int and long to float can lose some of the least significant bits during assignement. The same can happen for long to double [both have 64 bits]. int to double is fine though.

You may have to explicitly cast when there is an issue with range of values.

Object references
       Student s = new Student();
       here s is a variable that is an object reference. It holds bits that reference the student object in memory. It is not the object itself. 
       Student s means allocate memory for a Student reference variable
       new Student() means allocate memory for a student object
       Objects are created and stored on the Heap.
       Default reference of an object reference is null, untill it is explicitly initialized. If you try to reference a member of a null pointer, you will get a NullPointerException.

Statements
They are what constitutes a program.
Every statement ends with a semi colon and is a command to be excecuted.
A statement changes program state.
3 kinds of statements
  declarations eg int count = 25;
  expression statements eg count = 25; count++;
  control flow statements eg if(count < 100){....}
  
  Only declaration statements can be defined at class level. Expression or control flow methods can be part of other sections like methods. 

Arrays
An array is a data structure. A data structure is an organized collection of related data. An array is a container object that holds a fixed number of values of single type. Since an array is an object it is stored on the heap. The variable referencing it is an object reference.
Creating an array
	 int[] myArray = new int[7] // each element by default is zero (default int value)
	 int[] = new int[]{9,11,2,3}; // no need to specify array size here
	 int[] myArray = {9,11,2,5};
	 int myArray[]; is also ok so it is up to you.
	 so public static void main(String args[]) is oK!
	 array length = array.length
Array of Object references
      Student students[] = new Student[2];
Random access
       Linear layout, contiguously -> fast random access. Accessing is O(1) - constant time
       Searching an array is O(n) however, linear time. This can be modified with data structures.
Remember that an array is an object that stores a fixed number of elements. All these elements should be of a single type.

2D Arrays
   Creation: int myArray[][] = new int[4][2]; no. of rows first, columns next [x][y];
Internally JVM creates a one dimensional array and each element refers to each of the 4 rows. Each element is actually an object reference referring to another int array with 2 elements. So a 2D array is actually implemented as a 1D array with object references. These references point to arrays themselves
	   Look at array declaration
	   	type myArray[] -> array of type
		type myArray[][] -> array of int array

int myArray[][] = new int[][]{ {9,11}, {2,5}, {3,4} }; OR
int myArray[][] = { {9,11}, {2,5}, {3,4} };

Array with Irregular rows:
      int myArray[][] = new int[2][];
      myArray[0] = new int[5];
      myArray[1] = new int[2];
      so first row has 5 columns and second row has 2 columns
      This helps avoid storing duplicate or unwanted rows and save storage space. This is very useful for large matrices.
.length of a 2D array returns the number of rows it contains

3D Arrays
Rare in practice.
int myArray = new int[4][4][4];

Methods
Variables define object state. Methods define object behavior.
Methods have self-contained logic that can be used many times
All software's algorithms are coded into methods and nothing can be achieved without them.
They can receive input and generate output
Syntax of a method
       returnType methodName(type param1, type param2,...){

       		  return someValue;
		  }

Method signature includes only methodName(type param1, type param2...); so only method name and its parameters, not its return type

Return types
       void - nothing to return
       if return type is something other than void, then the method must return something.
       The return value must be compatible with return type of method eg an int method can return a byte however a byte method can only return a downcasted int or narrowed to byte  since int is larger than byte.

Methods help avoid duplicate code - reduce maintenance headaches
Divide complex logic into multiple smaller pieces in their own methods - this promotes software reusability, clean and readable code. Each method should do only one thing and no more.

Method types
       instance methods
       		Object-level methods
		Invocation: dot operator eg objectRef.methodName()
		Affect object state by
		       affecting instance variables
		       invoking other instance methods in that class
	static methods
	       have keyword static in declaration otherwise they are instance methods
	       are class-level methods - no access to state ie cannot access
	       instance variables/methods
	       can access static variables
	       invocation: className.methodName()
	       can access other static methods

Passing Data
	When primitives are passed to a function, their updates within the function do not affect the state of the variable in the calling environment. However, if an object reference is passed to a method, the object is also updated in the calling environment.
	Pass by value
	primitives are stored in 3 components: 
	<logical name, memory address, value> 
	At run time, for a primitive variable only memory address and value are available. The memory address is provided by the logical name
	
	For object references, <object reference, memory address of actual object>

Pass by value = a copy of the primitive argument is passed
     Object reference = value of memory address is passed.
Java is always pass by value during method invocation; Remember that when object references are passed to methods, it is a reference to the actual object that is passed.

METHOD INVOCATION AND ARRAY NOTICE
It when calling a method with an array literal, the following is valid
   function(new int[]{1,3,5}), if you try function({1,3,5}) THIS IS INVALID
   this kind of array {1,3,5} is only valid at array initialization say 
   int arr[] = {1,3,5}; but it is invalid for re-initialization or method calls.

Method Overloading
multiple methods have the same name but different parameter list.
to overload a method YOU MUST change either the parameters or parameter types or both. Changing the RETURN TYPE DOESN't MATTER
Applies to instance and static methods.
	eg boolean updateProfile(int newID){...}
	   boolean updateProfile)int newID, char gender){...}
If two functions have compatible data types, the function that gets called is the one that is closest to the data type submitted
   eg void overload(int i) {...} and void overload(short i){...} if someone calls byte b = 23; overload(23), then overload(short) is called since it has the next larger data types.
You would have a compilation error if
    you try to overload a funtion by just changing the return type eg 
    void updateProfile(int newId){...} and boolean updateProfile(int newId){...}
    you will also get an error if you just make the same signature with static.
In all these you will get a duplicate method error.

varargs
from Java 5 onwards methods can have variable number of arguments.These special types of parameters are called varargs and even though it is a single parameter it can take 0, 1 or many arguments. It is always the last parameter specified (or the only one if the method has no other arguments)
    Syntax: three dots following parameter (called ellipsis) type eg
    	    foo(boolean flag, int... items)
Invocation: array of any size eg (from above) foo(true, new int[]{1,2,3});
	    commma-separated arguments eg foo(true, 1,2,3); here 1,2,3 are the varargs. Here those last three numbers are automatically converted to an array. Within the method the vargarg is treated like a normal array.
	    The varargs can also be ignored completely eg foo(true). In this case, an empty array will be passed to the varargs parameter.
	    Varargs restrictions:
	    	    - must be last variable in the invocation
		    - cannot have two varargs in an invocation (violates the rule above)
Why varargs in the first place? Why not just an array?
    provides simpler and flexible invocation
    can choose to not use it and function will still run.
    printf is a method introduced in Java 5 which uses varargs
    printf(String format, Object....args);
    eg System.out.printf("DOB: %d/%d/%d", 1,1,1978);

    varargs & main Method
    public static void main(String args[]){...} OR
    public static void main(String...args){...}

    varargs & Overloaded methods
    a vararg is made into an array and so the following are duplicates
    foo(boolean flag, int...items);
    foo(boolean flag, int[] items);

    varargs method will be matched last

Constructor
Runs on object creation. Initializes object state (that is its instance variables)
     eg Student s = new Student();
     Student() invokes the constructor
     Syntax of constructor
     	    ClassName(type param1, type param2,...){
	    ...
	    }
	    
	    looks like a method but it does not have a return type
eg class Student{
   	 int id;
	 Student(int newId){
	 id = newId;
}
   
}

In the above class definition, the constructor is:
        Student(int newId){
	 id = newId;
} and it initializes each new Student object with an id value of newId

If a constructor is not provider, the compiler will create a default constructor called a no-args constructor (no parameters).
eg class Student{
   int id;
} 
the above class has no class constructor so on compilation, the compiler will add a no-args constructor:
    class Student{
    int id:
    Student(){}
}

This now allows us to create a new object that we can reference by
     Student s = new Student();
Note that once an object has a constructor and that constructor requires a variable, you cannot create a new object using the no-args constructor.

Constructor overloading
Can be done just like methods. Parameter list must be different. Constructor names are always the same as the class name anyway. 
Why constructor overloading?
    to create objects with different capabilities eg Java's file output handling
    FileOutputStream(String name, boolean append) // open a file and append
    FileOutputStream(String name) // overwrite the contents of existing file
    
Constructors can have a return statement but it doesn't return anything.
    
we use this so that we can access instance variables that are hidden (or shadowed) by local variables.
   class Student{
   	 int id;
	 String name;
	 void updateProfile(int newID, String name){
	      id = newId;
	      this.name = name;
	      }
}

we use this.name in the updateProfile() method because one of the method parameters is called name which happens to be one of the instance variables of the Class. So anytime you are in the method and you use name, you are referring to the parameter name. You'd have to use this.name in order to get the instance variable. 
Static methods are class methods so they can not use the this reference as this reference is used to access variables and instance methods only. 

You can run a class from a different file in another as Java will automatically search and compile the file with the right class. You do not need to compile both files.

Reassigning Object References
By default Java passes by reference. See the ReassignObjectReferences.java file. Any object in memory left without reference will be freed up by Java's garbage collection

Operator
	A symbol which performs an operation on its operands and produces a result.
Unary operator - operates on one operand eg -x, x++;
Binary operator - operates on two operands. placed between operands (infix)
Ternary operator uses two symbols a ? and a : eg (x > 3)? x : 0

Arithmetic Operators
+ addition eg int i = 5 + 2; (+ can also be used to concatenate strings)
- subtraction
Note that both + and - can be used as unary operators eg -x or +x
* multiplication
/ division
% modulus - returns the remainder
++ increment - post-increment (x++) and pre-increment (--x);
-- decrement - post-decrement (x--) or pre-decrement (--x);

Arithmetic operators apply to all primitive types except boolean.
Compound arithmetic assignment x = x + 5 => x += 5; others include -=, *=, /=, %=

Arithmetic Operation Rules
	   Operator precedence rules
	   1. Multiplicative operators (*, /, %) have higher precedence over additive operators.
	   2. Operators in the same level will be evaluated left to right
	   3. Parentheses can be used to change the order of evaluation
	   
Operand Promotion
	Operands smaller than int are promoted to int before addition is applied[byte, short or char]
	eg 127(byte) + 1 (byte) -> 127 (int) + 1 (int) -> 128 (int)
	'a' + 'b' = 195 why? char is treated as a 16 bit unsigned integer
	'a''s decimal value is 97 and 'b' is 98 in UTF-16
	4. Same type operations if both operands are int, long, float or double, then operations are carried in that type and evaluated to a value of that type thus 1 / 2 = 0 not 0.5
	Mixed Type Operations
	If both operands belong to different types, then the smaller type is promoted to larger type (note that long is converted to float even though long is 64 bit and float is 32 bit - float has a greater +).
	Comparison Operators/Relational Operators
	compare one operand with another and test some condition. Since we are testing a condition, the output will be a boolean value. Key for flow control statements
	< lt	<= le  > gt  >= ge	 == eq   != neq
Logical operators/conditional operators
comparison operators alone can only test a single condition eg if(x > 7){..}
How about testing multiple conditions? eg (x > 7) and (y < 2)?

&& AND	  || OR	  ! NOT

With these logical operators we can test one or more conditions. Logical operators just like relational operators will return boolean values.They can be used in control flow statements.	 

&& and || are short circuit operators because they can quickly evaluate without checking both sides of the expression eg  left operand && right operand -> this will evaluate to false if left operand is false and will not wait to check right operand. It only checks right operand if left is true. 
left operand || right operand also evaluates fast without checking if left operand is true.
These two short circuit operators can improve run time performance.
&& prevents NullPointerException by preventing us from accessing an object which is null eg if(s != null && s.getGender() == "male"){...} here the && prevents us from just trying to access the getGender method on a null pointer.
Operator precedence
	 ! then && then ||
	 you can use parentheses to change evaluation order

Bitwise Operators
operate on bits. Operands can be integers or boolean
	Applications - mostly in embedded systems with resource constrained environments where things must be manipulated very efficiently.
	Hash tables eg Java HashMap's hash function
	Compression and encryption
Bitwise Operators
	& returns 1 if both bit inputs are 1
	| returns 1 if either of input bits is 1
	^ returns 1 if only one of the input bits is 1
	~ inverts bits of its operand
	bitwise & and | are non-short circuit operators so they always check both operands unlike in && and ||
	Compound bitwise assignment &=
Bit Shift Operators
    shift bits. Their operands must be integers.
    << left shift
    >>> unsigned right shift
    >> signed right shift [preserves the sign of the original number]
    Uses - faster than multiplication and division and compilers can use them. Used in games and embedded programming. Also systems without floating points.Can also be expressed with compound expressions >>=, >>>= <<=

Control-flow
If body of any of the control statements has more than one statement, use curly braces. Note that it is also good practice to include curly braces anyway
if, for, while, do while, switch

if(x > 7){...}
else if{...}
else {...}

switch(x){
	case a:
	     do ...;
	     break;
	case b:
	     do ...;
	     break;
	default:
		do....;

}					

a switch expression's numerical final value SHOULD EVALUATE TO AN INTEGER. Thus items submitted to the switch expression should be converted to integers and then compared.No duplicate values should be placed in the switch expression. Note that the range of the case values should be in the data type range.
Case label value must be a constant expression.Can be an integer or string literal. eg final int = 4;
only constants can be used as cases
                                 in a switch statement, hence the use of fin\
al. This is because the switch statement is setup during compilation so it n\
eeds the final values. A null case cannot be used as well
switch statement cannot be used in the following conditions:
       - there is more than one condition to test
       - tests other than equality eg month >= 3;
       - switch cannot be used for variables that are not integers, strings or enum
       - if at least one of the case label restrictions does not apply.
switch is preferred if:
       - readability improves
       - intent - the switch is clear with what variable is being evaluated
       - switch is faster than if because case labels are known at compile time. Also, switch has less comparisons. In the worst case, an if statement will take O(n) time to evaluate whereas a switch statement is O(1)
Ternary Operator
Can be used as an alternative to an if else statement.
Shorthand for if-else with single statements
	  result = (boolean-expression)? value-if-true : value-if-false;
**Note that parentheses are optional but they improve readability.
When to use ternary operations - to improve code readability
Ternary operator cannot be an expression statement. 
 (x > 2)? 3: 4; is invalid. Ternary operator can only be used if we are assigning something. eg int y = (x > 2)? 3:4;

for Statement
To iterate over array elements.
for(int i = 0; i < 10; i++){...}
 Initialization part of for loop can be done on the outside. eg 
   	   int i = 0;
	   for(;i<10; i++){...}
for-each Statement
Iterate arrays & other data structures
for(int i: array){
	System.out.println(i);
}
Increments are taken care of internally. Reduces chances of errors in nested loops.
Traditional for loop should be used when you need to transform one item in the index. Also useful when you want to traverse two arrays in parallel.
eg for(int i = 0, j = 0; i < I_array.length && j < J_array.length; i++,j++){
   System.out.println(I_array[i]+ " "+ J_array[j]);
}
Traditional for loops are also good for backward iteration. With for each you can only move forward.
For each has much cleaner cde.
While loop
Run if you do not know the number of times the loop should run
Do while
Runs at least once. Note that the do{...}while(...); expression ends with a semicolon;
Infinite loops
	 while(true){
		if(getTime() == 8){
			     sendEmails();
			     }
			     }
break statement
Exits immediately enclosing swith or loop (for/while). A break statement needs to be in a switch or for/while loop otherwise it will be invalid
Labeled break Statement
How about if you want to exit one of the outer switch/loop. First we label the block statement label: block statement 
A block statement contains 0 or more statements enclosed in curly braces eg any control statement with a brace. Once we have labeled a block , we can use the break label; command to break;
continue statement
	 continues with the next iteration of the innermost loop. skips the rest of the loop and goes to the next cycle.
There is also a labeled continue statement. First we label the loop we want then we use continue label. the continue label cannot be used with an if statement though. break can be used with it though.
Variable scope
Every variable has a scope
Entire class variables/globals
