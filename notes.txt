What is Java?
-general purpose, object oriented, platform independent, concurrent and very fast programming language.
-invented in the mid 90s. Similar to C & C++
-simplicity was the goal. Java has automatic memory management using garbage collection. No manual memory management like C or C++
-secure

Goals during creation
- low memory consumption
- should allow devices to commuicate
- should be independent of platforms - run on target device with no issues
- should be secure
- should support multithreading so that devices can perform other tasks
C++ was limited due to lack of platform independence
James Gosling created Oak then renamed Java. It was too advanced and rejected by cable companies.
HotJava browser created by Sun which made internet interactions more dynamic by embedding Java programs
First version released in 1996.

Compilation
- verify syntax & semantics of source code
- optimize code
- generates machine code

Platform dependency
-If processor differs, the software has to be recompiled in order to run

Interpreter
No compiling. Interpreter handles source code and produces results
Compiler path: source code -> compiler -> machine code -> CPU -> results
Interpreter path: source code -> interpreter -> results
Interpreter is a virtual machine that simulates a CPU. 
Fetch & Execute cycle:
      CPU		<- Memory	<- Storage
      (executes)	-> data

Interpreter also fetches instructions from memory. It understands the statement then executes precompiled machine code in its library.
As long as a platform has an interpreter suitable for it, code will be made once and run anywhere
Pros of interpreter:
     platform independence
     no compilation step
     easier to update due to no compilation
Limitations of intepreter
	    Slow due to costly memory access. Registers make compiled 
	    languages much faster
	    Source code is reinterpreted every time
	    Interpreter is loaded into memory

Java Intepretation
     source code -> Java Compiler -> Java byte code(platform independent intermediate) -> JVM (Java virtual machine, dependent on machine) -> results

eg Hello.java (source) -> javac Hello.java [compilation] -> Hello.class (Java byte code) -> Hello.class can now be executed on any platform with JVM via java Hello

Java Speed?
How is it fast if interpretation is slow?
- Bytecode interpretations are much faster because Java bytecode is
  compact, compiled and optimized already. Java Bytecode's compactness also
  allows quick transfer across networks. Remember that Java was designed to work with multiple types of devices on a network
- Just-in-time compilation (JIT) - monitors frequently executed bytecodes "hotspots". These hotspots are converted to machine code and cached. This cached machine code is executed faster later from the cache. This is called dynamic compilation. The caching gives Java its speed

Java Virtual Machine
- the cornerstone of Java
- is an abstract computing machine
- executes instruction set (Java bytecode)
- manipulates memory at runtime
- is secure across networks
Abstract JVM specification

Java Software Family
Java Standard Edition(Java SE)
     standalone applications for desktops & servers
Java Enterprise Edition (Java EE)
     enterprise applications for servers eg e-comerce websites
     includes Java SE
Java Micro Edition (Java ME)
     applications for resource-constrained devices

Java SE 
Java Runtime Environment
     	  only run Java programs
Java Development Kit (JDK)
	  develop & run Java programs

Java program structure
     CLASS
     variable declarations
     constructors, statements
     methods
     nested classes, statements

if you have a class with the modifier public, then the name of the file has to be the same as that class name

main method is invoked first when the Java Virtual Machine (JVM) loads the class bytecodes.
It must be declared as 
   public - for JVM to be able to invoke it. otherwise it will not run. public means that you can call the method from outside of the class you are currently in. This is necessary because this method is being called by the Java runtime system which is not located in your current class.
   static - access modifier which allows us to call this method directly using the class name without creating an object of it. So every function in a class that only performs tasks in it should be static eg static int add_num
   void - return values mean different things on different platforms. Java is avoiding that problem by having its main method return nothing. There are other ways to exit the program eg System.exit()

Classes & Objects
OOP roots back to 1960s. Conceived to implement large projects and implement
real world scenarios in a natural way

Classes are blueprints and objects are instances of objects
Class members - variables, methods, member classes, member interfaces

class Student{
//variable declarations

//method declarations
}

to initialize an object we use the new key word
the dot operator is used to access the object's state and methods

Java Basics
     comments //ignore rest of line /*ignore block*/
     case-sensitive Test != test
     classes, methods and varialbles must start with letter, underscore or $
     some reserved keywords like class, interface, enum...
     Printing to console
     	      System.out.println(string) - print and go to new line
	      System.out.print(string) - print and place cursor after the printed string.

Variables
	containers of data or references to objects.
	always have a type associated with it and they will hold data of that type
	variable type also determines the methods that can be performed on that type. 
	Variable type is declared when the object is created. It cannot be changed thereafter. Thus Java is a statically-typed language. There is static type checking to prevent assigning a type that is not the original type.
	Dynamically typed languages allow variables to change their types at any point eg JavaScript
	Static type checking has the advantage that it allows earlier detection of programming mistakes.
	Variable declaration <type> <name> = [literal or expression]
	Variable is something whose value can be changed
Variable Kinds
	 instance variables or attributes - declared directly in the body of the clas. If not initialized they always have a default value. They represent state specific to each object of a class. Cannot be reinitialized directly within a class. Reinitialization is done within object methods only
	 static variables - declared in class with keyword static. Is shared by all objects in that class. Only one copy is maintained per class regardless of the number of objects of class. Also get default value and cannot be reinitialized directly within the class.
	 local variables - declared in methods. Includes method parameters. Not accessible outside of the method. They only exist on the stack when the method is mounted and they are cleared off after its execution. No need for default value.

Variable types
	 Primitive
	 8 types - boolean, byte, short, int, long, float, double, char (char is internally represented as an unsigned int)
	   integers
		whole or fixed point numbers - byte, short, int, long
		represented by signed two's complement.
		Binary addition:
		Sign-magnitude representation of bits makes the left-most
		bit 1 for negative and 0 for positive. There are however
		two problems associated with this representation
		1. There are two representations of zero eg for 8 bits -
		1000 0000 and 0000 0000 are -0 and +0
		2. Binary addition of positive and negative numbers doesn't
		work - eg add 16 [ 0001 0000 ] to -24 [ 1001 1000 ] = 
		1010 1000 or -40
		In order to make binary addition work, we need a way to find
		a number which when added to another binary number results
		in 0000 0000 (in a 8 bits for example). In other words for
		every bit pattern of N bits there is a corresponding bit 
		pattern of N bits which produces an N-bit zero when the two
		patterns are used as operands for the binary addition
		algorithm. Each pattern can be thought of representing the
		negative of the number that is represented by the other 
		pattern.
		This representation is called two's complement. It is 
		derived as follows: 
		1. Start with an N-bit representation of an integer
		2. To calculate the N-bit representation of the negative
		integer, reflect each bit of the bit pattern
		(change 0 to 1 and 1 to 0)
		3. Add one.

		integers represent whole or fixed-point numbers
		types: byte(8 bit)[-128 to +127], short(16 bit)[-32768 to 32767 (~32 000)], int(32 bit) [-2147483648 to 2147483647 (~2 billion)], long(64bit)
		default of all ints is 0 for class-level variables, however within methods, they need to be initialized before use
		long = 10000000L // L required if above the int range
		int also stores hexadecimal numbers or Java 7 binary or octals. Underscores can be used in between digits to improve readability eg int x = 1_243_300;
Floatng-Point Numbers
real numbers with 32 bit float or 64-bit double
   double is more precise
   Data representation ~ 32 and 64 bit IEEE 754 flaating point convention
   float -3.4E38 to 3.4E38 where E is power 10
   double -1.7E308 to 1.7E308
   float f = 123.4f //TRAILING F is required (upper or lower case)
   double d = 123.4 //TRAILING D is optional

   General rule - avoid float and double if exact answers are required. Unsuitable for money calculations. Recommended to use BigDecimal which comes in Java library. You can use int or long but you have to keep track of decimal point yourself.
Floating point arithmetic is not as fast as integer. In general stick with int and double. double's greater precision is useful. Use float if memery saving is important.

Characters
represented by 16 bit unsigned integers internally
range is 0 to 2^16 -1 (since we are not dealing with negative numbers)
default value is '\u0000' a unicode hexadecimal escape sequence
Java uses 16 bit unicode scheme (UTF-16) which means that they are first encoded in UTF-16 format (a hexadecimal number) then stored as a 16 bit unsigned int.UTF is one of the implementations of the unicode standards.
eg 'A' is encoded to hexadecimal 0041 which is then stored as a 16 bit unsigned int 00000000 01000001
   char c = 'A'; // always in single quotes
   char c = 65; // can also be declared with an unsigned int. It will be assigned the UTF-16 character corresponding to 65. thus we can add to char variables just like we do with ints
   char c = '\u0041'; // assigned with a hexadecimal unicode number. Useful if keyboard doesn't allow us to assign certain characters.
   char c = 0x41; // hexadecimal converted to decimal number and character corresponding to that UTF number is assigned.

Boolean
Boolean bit storage is JVM specific/ machine specific. Has value of true or \
false. Default value is false;

Type Casting
Assign variable or literal of one data type to another type eg change a byte to an int or long to int. It is only available for numeric to numeric casting. Since an character is stored as an unsigned int, it can also be typecasted. Cannot cast to boolean or viceversa.
Implicit typecasting:
	 smaller to larger type conversion - widening conversion
	 eg int x = 65; long y = x; (implicit casting by compiler)
	 assigning an int to a float is implicit. As long as range of values of the final type is larger than the input type, casting is implicit eg long int to float is implicit. So assigning char to int is implicit.

Explicit typecasting
	 when assigning a variable of larger range to a smaller range type = narrowing conversion. note that even though char and short are both 16 bits, char has a larger positive range.
	 long y = 42;
	 int x = (int)y;
	 without the above cast we would get a compiler error due to the different type.

* althogh implicit casting is taken care of by the compiler, you can still explicitly cast.
Out of range assignments result in information loss
    eg byte narrowByte = (byte)123456; // narrowByte = 64 (only lowest rightmost 8 bits are saved)
Truncation
Floating-point to int/char will always truncate the number
	       eg int x = (int)3.14f; // x = 3;
	       	  int y = (int)0.9; // y = 0;
		  char c = (char) 65.5; y = 'A'

Information Loss Implicit Casting
Assigning int to float or long to float can result in loss of precision. Assigning long to double results in loss as well.
int and long to float can lose some of the least significant bits during assignement. The same can happen for long to double [both have 64 bits]. int to double is fine though.

You may have to explicitly cast when there is an issue with range of values.

Object references
       Student s = new Student();
       here s is a variable that is an object reference. It holds bits that reference the student object in memory. It is not the object itself. 
       Student s means allocate memory for a Student reference variable
       new Student() means allocate memory for a student object
       Objects are created and stored on the Heap.
       Default reference of an object reference is null, untill it is explicitly initialized. If you try to reference a member of a null pointer, you will get a NullPointerException.

Statements
They are what constitutes a program.
Every statement ends with a semi colon and is a command to be excecuted.
A statement changes program state.
3 kinds of statements
  declarations eg int count = 25;
  expression statements eg count = 25; count++;
  control flow statements eg if(count < 100){....}
  
  Only declaration statements can be defined at class level. Expression or control flow methods can be part of other sections like methods. 

Arrays
An array is a data structure. A data structure is an organized collection of related data. An array is a container object that holds a fixed number of values of single type. Since an array is an object it is stored on the heap. The variable referencing it is an object reference.
Creating an array
	 int[] myArray = new int[7] // each element by default is zero (default int value)
	 int[] = new int[]{9,11,2,3}; // no need to specify array size here
	 int[] myArray = {9,11,2,5};
	 int myArray[]; is also ok so it is up to you.
	 so public static void main(String args[]) is oK!
	 array length = array.length
Array of Object references
      Student students[] = new Student[2];
Random access
       Linear layout, contiguously -> fast random access. Accessing is O(1) - constant time
       Searching an array is O(n) however, linear time. This can be modified with data structures.
Remember that an array is an object that stores a fixed number of elements. All these elements should be of a single type.

2D Arrays
   Creation: int myArray[][] = new int[4][2]; no. of rows first, columns next [x][y];
Internally JVM creates a one dimensional array and each element refers to each of the 4 rows. Each element is actually an object reference referring to another int array with 2 elements. So a 2D array is actually implemented as a 1D array with object references. These references point to arrays themselves
	   Look at array declaration
	   	type myArray[] -> array of type
		type myArray[][] -> array of int array

int myArray[][] = new int[][]{ {9,11}, {2,5}, {3,4} }; OR
int myArray[][] = { {9,11}, {2,5}, {3,4} };

Array with Irregular rows:
      int myArray[][] = new int[2][];
      myArray[0] = new int[5];
      myArray[1] = new int[2];
      so first row has 5 columns and second row has 2 columns
      This helps avoid storing duplicate or unwanted rows and save storage space. This is very useful for large matrices.
.length of a 2D array returns the number of rows it contains

3D Arrays
Rare in practice.
int myArray = new int[4][4][4];

Methods
Variables define object state. Methods define object behavior.
Methods have self-contained logic that can be used many times
All software's algorithms are coded into methods and nothing can be achieved without them.
They can receive input and generate output
Syntax of a method
       returnType methodName(type param1, type param2,...){

       		  return someValue;
		  }

Method signature includes only methodName(type param1, type param2...); so only method name and its parameters, not its return type

Return types
       void - nothing to return
       if return type is something other than void, then the method must return something.
       The return value must be compatible with return type of method eg an int method can return a byte however a byte method can only return a downcasted int or narrowed to byte  since int is larger than byte.

Methods help avoid duplicate code - reduce maintenance headaches
Divide complex logic into multiple smaller pieces in their own methods - this promotes software reusability, clean and readable code. Each method should do only one thing and no more.

Method types
       instance methods
       		Object-level methods
		Invocation: dot operator eg objectRef.methodName()
		Affect object state by
		       affecting instance variables
		       invoking other instance methods in that class
	static methods
	       have keyword static in declaration otherwise they are instance methods
	       are class-level methods - no access to state ie cannot access
	       instance variables/methods
	       can access static variables
	       invocation: className.methodName()
	       can access other static methods

Passing Data
	When primitives are passed to a function, their updates within the function do not affect the state of the variable in the calling environment. However, if an object reference is passed to a method, the object is also updated in the calling environment.
	Pass by value
	primitives are stored in 3 components: 
	<logical name, memory address, value> 
	At run time, for a primitive variable only memory address and value are available. The memory address is provided by the logical name
	
	For object references, <object reference, memory address of actual object>

Pass by value = a copy of the primitive argument is passed
     Object reference = value of memory address is passed.
Java is always pass by value; Remember that when object references are passed to methods, it is a reference to the actual object that is passed.

Method Overloading
multiple methods have the same name but different parameter list.
to overload a method YOU MUST change either the parameters or parameter types or both. Changing the RETURN TYPE DOESN't MATTER
Applies to instance and static methods.
	eg boolean updateProfile(int newID){...}
	   boolean updateProfile)int newID, char gender){...}
If two functions have compatible data types, the function that gets called is the one that is closest to the data type submitted
   eg void overload(int i) {...} and void overload(short i){...} if someone calls byte b = 23; overload(23), then overload(short) is called since it has the next larger data types.
You would have a compilation error if
    you try to overload a funtion by just changing the return type eg 
    void updateProfile(int newId){...} and boolean updateProfile(int newId){...}
    you will also get an error if you just make the same signature with static.
In all these you will get a duplicate method error.
