What is Java?
-general purpose, object oriented, platform independent, concurrent and very fast programming language.
-invented in the mid 90s. Similar to C & C++
-simplicity was the goal. Java has automatic memory management using garbage collection. No manual memory management like C or C++
-secure

Goals during creation
- low memory consumption
- should allow devices to commuicate
- should be independent of platforms - run on target device with no issues
- should be secure
- should support multithreading so that devices can perform other tasks
C++ was limited due to lack of platform independence
James Gosling created Oak then renamed Java. It was too advanced and rejected by cable companies.
HotJava browser created by Sun which made internet interactions more dynamic by embedding Java programs
First version released in 1996.

Compilation
- verify syntax & semantics of source code
- optimize code
- generates machine code

Platform dependency
-If processor differs, the software has to be recompiled in order to run

Interpreter
No compiling. Interpreter handles source code and produces results
Compiler path: source code -> compiler -> machine code -> CPU -> results
Interpreter path: source code -> interpreter -> results
Interpreter is a virtual machine that simulates a CPU.
Fetch & Execute cycle:
      CPU		<- Memory	<- Storage
      (executes)	-> data

Interpreter also fetches instructions from memory. It understands the statement then executes precompiled machine code in its library.
As long as a platform has an interpreter suitable for it, code will be made once and run anywhere
Pros of interpreter:
     platform independence
     no compilation step
     easier to update due to no compilation
Limitations of intepreter
	    Slow due to costly memory access. Registers make compiled
	    languages much faster
	    Source code is reinterpreted every time
	    Interpreter is loaded into memory

Java Intepretation
     source code -> Java Compiler -> Java byte code(platform independent intermediate) -> JVM (Java virtual machine, dependent on machine) -> results

eg Hello.java (source) -> javac Hello.java [compilation] -> Hello.class (Java byte code) -> Hello.class can now be executed on any platform with JVM via java Hello

Java Speed?
How is it fast if interpretation is slow?
- Bytecode interpretations are much faster because Java bytecode is
  compact, compiled and optimized already. Java Bytecode's compactness also
  allows quick transfer across networks. Remember that Java was designed to work with multiple types of devices on a network
- Just-in-time compilation (JIT) - monitors frequently executed bytecodes "hotspots". These hotspots are converted to machine code and cached. This cached machine code is executed faster later from the cache. This is called dynamic compilation. The caching gives Java its speed

Java Virtual Machine
- the cornerstone of Java
- is an abstract computing machine
- executes instruction set (Java bytecode)
- manipulates memory at runtime
- is secure across networks
Abstract JVM specification

Java Software Family
Java Standard Edition(Java SE)
     standalone applications for desktops & servers
Java Enterprise Edition (Java EE)
     enterprise applications for servers eg e-comerce websites
     includes Java SE
Java Micro Edition (Java ME)
     applications for resource-constrained devices

Java SE
Java Runtime Environment
     	  only run Java programs
Java Development Kit (JDK)
	  develop & run Java programs

Java program structure
     CLASS
     variable declarations
     constructors, statements
     methods
     nested classes, statements

if you have a class with the modifier public, then the name of the file has to be the same as that class name

main method is invoked first when the Java Virtual Machine (JVM) loads the class bytecodes.
It must be declared as
   public - for JVM to be able to invoke it. otherwise it will not run. public means that you can call the method from outside of the class you are currently in. This is necessary because this method is being called by the Java runtime system which is not located in your current class.
   static - access modifier which allows us to call this method directly using the class name without creating an object of it. So every function in a class that only performs tasks in it should be static eg static int add_num
   void - return values mean different things on different platforms. Java is avoiding that problem by having its main method return nothing. There are other ways to exit the program eg System.exit()

Classes & Objects
OOP roots back to 1960s. Conceived to implement large projects and implement
real world scenarios in a natural way

Classes are blueprints and objects are instances of objects
Class members - variables, methods, member classes, member interfaces

class Student{
//variable declarations

//method declarations
}

to initialize an object we use the new key word
the dot operator is used to access the object's state and methods

Java Basics
     comments //ignore rest of line /*ignore block*/
     case-sensitive Test != test
     classes, methods and varialbles must start with letter, underscore or $
     some reserved keywords like class, interface, enum...
     Printing to console
     	      System.out.println(string) - print and go to new line
	      System.out.print(string) - print and place cursor after the printed string.

Variables
	containers of data or references to objects.
	always have a type associated with it and they will hold data of that type
	variable type also determines the methods that can be performed on that type.
	Variable type is declared when the object is created. It cannot be changed thereafter. Thus Java is a statically-typed language. There is static type checking to prevent assigning a type that is not the original type.
	Dynamically typed languages allow variables to change their types at any point eg JavaScript
	Static type checking has the advantage that it allows earlier detection of programming mistakes.
	Variable declaration <type> <name> = [literal or expression]
	Variable is something whose value can be changed
Variable Kinds
	 instance variables or attributes - declared directly in the body of the clas. If not initialized they always have a default value. They represent state specific to each object of a class. Cannot be reinitialized directly within a class. Reinitialization is done within object methods only
	 static variables - declared in class with keyword static. Is shared by all objects in that class. Only one copy is maintained per class regardless of the number of objects of class. Also get default value and cannot be reinitialized directly within the class.
	 local variables - declared in methods. Includes method parameters. Not accessible outside of the method. They only exist on the stack when the method is mounted and they are cleared off after its execution. No need for default value.

Variable types
	 Primitive
	 8 types - boolean, byte, short, int, long, float, double, char (char is internally represented as an unsigned int)
	   integers
		whole or fixed point numbers - byte, short, int, long
		represented by signed two's complement.
		Binary addition:
		Sign-magnitude representation of bits makes the left-most
		bit 1 for negative and 0 for positive. There are however
		two problems associated with this representation
		1. There are two representations of zero eg for 8 bits -
		1000 0000 and 0000 0000 are -0 and +0
		2. Binary addition of positive and negative numbers doesn't
		work - eg add 16 [ 0001 0000 ] to -24 [ 1001 1000 ] =
		1010 1000 or -40
		In order to make binary addition work, we need a way to find
		a number which when added to another binary number results
		in 0000 0000 (in a 8 bits for example). In other words for
		every bit pattern of N bits there is a corresponding bit
		pattern of N bits which produces an N-bit zero when the two
		patterns are used as operands for the binary addition
		algorithm. Each pattern can be thought of representing the
		negative of the number that is represented by the other
		pattern.
		This representation is called two's complement. It is
		derived as follows:
		1. Start with an N-bit representation of an integer
		2. To calculate the N-bit representation of the negative
		integer, reflect each bit of the bit pattern
		(change 0 to 1 and 1 to 0)
		3. Add one.

		integers represent whole or fixed-point numbers
		types: byte(8 bit)[-128 to +127], short(16 bit)[-32768 to 32767 (~32 000)], int(32 bit) [-2147483648 to 2147483647 (~2 billion)], long(64bit)
		default of all ints is 0 for class-level variables, however within methods, they need to be initialized before use
		long = 10000000L // L required if above the int range
		int also stores hexadecimal numbers or Java 7 binary or octals. Underscores can be used in between digits to improve readability eg int x = 1_243_300;
Floatng-Point Numbers
real numbers with 32 bit float or 64-bit double
   double is more precise
   Data representation ~ 32 and 64 bit IEEE 754 flaating point convention
   float -3.4E38 to 3.4E38 where E is power 10
   double -1.7E308 to 1.7E308
   float f = 123.4f //TRAILING F is required (upper or lower case)
   double d = 123.4 //TRAILING D is optional

   General rule - avoid float and double if exact answers are required. Unsuitable for money calculations. Recommended to use BigDecimal which comes in Java library. You can use int or long but you have to keep track of decimal point yourself.
Floating point arithmetic is not as fast as integer. In general stick with int and double. double's greater precision is useful. Use float if memery saving is important.

Characters
represented by 16 bit unsigned integers internally
range is 0 to 2^16 -1 (since we are not dealing with negative numbers)
default value is '\u0000' a unicode hexadecimal escape sequence
Java uses 16 bit unicode scheme (UTF-16) which means that they are first encoded in UTF-16 format (a hexadecimal number) then stored as a 16 bit unsigned int.UTF is one of the implementations of the unicode standards.
eg 'A' is encoded to hexadecimal 0041 which is then stored as a 16 bit unsigned int 00000000 01000001
   char c = 'A'; // always in single quotes
   char c = 65; // can also be declared with an unsigned int. It will be assigned the UTF-16 character corresponding to 65. thus we can add to char variables just like we do with ints
   char c = '\u0041'; // assigned with a hexadecimal unicode number. Useful if keyboard doesn't allow us to assign certain characters.
   char c = 0x41; // hexadecimal converted to decimal number and character corresponding to that UTF number is assigned.

Boolean
Boolean bit storage is JVM specific/ machine specific. Has value of true or \
false. Default value is false;

Type Casting
Assign variable or literal of one data type to another type eg change a byte to an int or long to int. It is only available for numeric to numeric casting. Since an character is stored as an unsigned int, it can also be typecasted. Cannot cast to boolean or viceversa.
Implicit typecasting:
	 smaller to larger type conversion - widening conversion
	 eg int x = 65; long y = x; (implicit casting by compiler)
	 assigning an int to a float is implicit. As long as range of values of the final type is larger than the input type, casting is implicit eg long int to float is implicit. So assigning char to int is implicit.

Explicit typecasting
	 when assigning a variable of larger range to a smaller range type = narrowing conversion. note that even though char and short are both 16 bits, char has a larger positive range.
	 long y = 42;
	 int x = (int)y;
	 without the above cast we would get a compiler error due to the different type.

* althogh implicit casting is taken care of by the compiler, you can still explicitly cast.
Out of range assignments result in information loss
    eg byte narrowByte = (byte)123456; // narrowByte = 64 (only lowest rightmost 8 bits are saved)
Truncation
Floating-point to int/char will always truncate the number
	       eg int x = (int)3.14f; // x = 3;
	       	  int y = (int)0.9; // y = 0;
		  char c = (char) 65.5; y = 'A'

Information Loss Implicit Casting
Assigning int to float or long to float can result in loss of precision. Assigning long to double results in loss as well.
int and long to float can lose some of the least significant bits during assignement. The same can happen for long to double [both have 64 bits]. int to double is fine though.

You may have to explicitly cast when there is an issue with range of values.

Object references
       Student s = new Student();
       here s is a variable that is an object reference. It holds bits that reference the student object in memory. It is not the object itself.
       Student s means allocate memory for a Student reference variable
       new Student() means allocate memory for a student object
       Objects are created and stored on the Heap.
       Default reference of an object reference is null, untill it is explicitly initialized. If you try to reference a member of a null pointer, you will get a NullPointerException.

Statements
They are what constitutes a program.
Every statement ends with a semi colon and is a command to be excecuted.
A statement changes program state.
3 kinds of statements
  declarations eg int count = 25;
  expression statements eg count = 25; count++;
  control flow statements eg if(count < 100){....}

  Only declaration statements can be defined at class level. Expression or control flow methods can be part of other sections like methods.

Arrays
An array is a data structure. A data structure is an organized collection of related data. An array is a container object that holds a fixed number of values of single type. Since an array is an object it is stored on the heap. The variable referencing it is an object reference.
Creating an array
	 int[] myArray = new int[7] // each element by default is zero (default int value)
	 int[] = new int[]{9,11,2,3}; // no need to specify array size here
	 int[] myArray = {9,11,2,5};
	 int myArray[]; is also ok so it is up to you.
	 so public static void main(String args[]) is oK!
	 array length = array.length
Array of Object references
      Student students[] = new Student[2];
Random access
       Linear layout, contiguously -> fast random access. Accessing is O(1) - constant time
       Searching an array is O(n) however, linear time. This can be modified with data structures.
Remember that an array is an object that stores a fixed number of elements. All these elements should be of a single type.

2D Arrays
   Creation: int myArray[][] = new int[4][2]; no. of rows first, columns next [x][y];
Internally JVM creates a one dimensional array and each element refers to each of the 4 rows. Each element is actually an object reference referring to another int array with 2 elements. So a 2D array is actually implemented as a 1D array with object references. These references point to arrays themselves
	   Look at array declaration
	   	type myArray[] -> array of type
		type myArray[][] -> array of int array

int myArray[][] = new int[][]{ {9,11}, {2,5}, {3,4} }; OR
int myArray[][] = { {9,11}, {2,5}, {3,4} };

Array with Irregular rows:
      int myArray[][] = new int[2][];
      myArray[0] = new int[5];
      myArray[1] = new int[2];
      so first row has 5 columns and second row has 2 columns
      This helps avoid storing duplicate or unwanted rows and save storage space. This is very useful for large matrices.
.length of a 2D array returns the number of rows it contains

3D Arrays
Rare in practice.
int myArray = new int[4][4][4];

Methods
Variables define object state. Methods define object behavior.
Methods have self-contained logic that can be used many times
All software's algorithms are coded into methods and nothing can be achieved without them.
They can receive input and generate output
Syntax of a method
       returnType methodName(type param1, type param2,...){

       		  return someValue;
		  }

Method signature includes only methodName(type param1, type param2...); so only method name and its parameters, not its return type

Return types
       void - nothing to return
       if return type is something other than void, then the method must return something.
       The return value must be compatible with return type of method eg an int method can return a byte however a byte method can only return a downcasted int or narrowed to byte  since int is larger than byte.

Methods help avoid duplicate code - reduce maintenance headaches
Divide complex logic into multiple smaller pieces in their own methods - this promotes software reusability, clean and readable code. Each method should do only one thing and no more.

Method types
       instance methods
       		Object-level methods
		Invocation: dot operator eg objectRef.methodName()
		Affect object state by
		       affecting instance variables
		       invoking other instance methods in that class
	static methods
	       have keyword static in declaration otherwise they are instance methods
	       are class-level methods - no access to state ie cannot access
	       instance variables/methods
	       can access static variables
	       invocation: className.methodName()
	       can access other static methods

Passing Data
	When primitives are passed to a function, their updates within the function do not affect the state of the variable in the calling environment. However, if an object reference is passed to a method, the object is also updated in the calling environment.
	Pass by value
	primitives are stored in 3 components:
	<logical name, memory address, value>
	At run time, for a primitive variable only memory address and value are available. The memory address is provided by the logical name

	For object references, <object reference, memory address of actual object>

Pass by value = a copy of the primitive argument is passed
     Object reference = value of memory address is passed.
Java is always pass by value during method invocation; Remember that when object references are passed to methods, it is a reference to the actual object that is passed.

METHOD INVOCATION AND ARRAY NOTICE
It when calling a method with an array literal, the following is valid
   function(new int[]{1,3,5}), if you try function({1,3,5}) THIS IS INVALID
   this kind of array {1,3,5} is only valid at array initialization say
   int arr[] = {1,3,5}; but it is invalid for re-initialization or method calls.

Method Overloading
multiple methods have the same name but different parameter list.
to overload a method YOU MUST change either the parameters or parameter types or both. Changing the RETURN TYPE DOESN't MATTER
Applies to instance and static methods.
	eg boolean updateProfile(int newID){...}
	   boolean updateProfile)int newID, char gender){...}
If two functions have compatible data types, the function that gets called is the one that is closest to the data type submitted
   eg void overload(int i) {...} and void overload(short i){...} if someone calls byte b = 23; overload(23), then overload(short) is called since it has the next larger data types.
You would have a compilation error if
    you try to overload a funtion by just changing the return type eg
    void updateProfile(int newId){...} and boolean updateProfile(int newId){...}
    you will also get an error if you just make the same signature with static.
In all these you will get a duplicate method error.

varargs
from Java 5 onwards methods can have variable number of arguments.These special types of parameters are called varargs and even though it is a single parameter it can take 0, 1 or many arguments. It is always the last parameter specified (or the only one if the method has no other arguments)
    Syntax: three dots following parameter (called ellipsis) type eg
    	    foo(boolean flag, int... items)
Invocation: array of any size eg (from above) foo(true, new int[]{1,2,3});
	    commma-separated arguments eg foo(true, 1,2,3); here 1,2,3 are the varargs. Here those last three numbers are automatically converted to an array. Within the method the vargarg is treated like a normal array.
	    The varargs can also be ignored completely eg foo(true). In this case, an empty array will be passed to the varargs parameter.
	    Varargs restrictions:
	    	    - must be last variable in the invocation
		    - cannot have two varargs in an invocation (violates the rule above)
Why varargs in the first place? Why not just an array?
    provides simpler and flexible invocation
    can choose to not use it and function will still run.
    printf is a method introduced in Java 5 which uses varargs
    printf(String format, Object....args);
    eg System.out.printf("DOB: %d/%d/%d", 1,1,1978);

    varargs & main Method
    public static void main(String args[]){...} OR
    public static void main(String...args){...}

    varargs & Overloaded methods
    a vararg is made into an array and so the following are duplicates
    foo(boolean flag, int...items);
    foo(boolean flag, int[] items);

    varargs method will be matched last

Constructor
Runs on object creation. Initializes object state (that is its instance variables)
     eg Student s = new Student();
     Student() invokes the constructor
     Syntax of constructor
     	    ClassName(type param1, type param2,...){
	    ...
	    }

	    looks like a method but it does not have a return type
eg class Student{
   	 int id;
	 Student(int newId){
	 id = newId;
}

}

In the above class definition, the constructor is:
        Student(int newId){
	 id = newId;
} and it initializes each new Student object with an id value of newId

If a constructor is not provider, the compiler will create a default constructor called a no-args constructor (no parameters).
eg class Student{
   int id;
}
the above class has no class constructor so on compilation, the compiler will add a no-args constructor:
    class Student{
    int id:
    Student(){}
}

This now allows us to create a new object that we can reference by
     Student s = new Student();
Note that once an object has a constructor and that constructor requires a variable, you cannot create a new object using the no-args constructor.

Constructor overloading
Can be done just like methods. Parameter list must be different. Constructor names are always the same as the class name anyway.
Why constructor overloading?
    to create objects with different capabilities eg Java's file output handling
    FileOutputStream(String name, boolean append) // open a file and append
    FileOutputStream(String name) // overwrite the contents of existing file

Constructors can have a return statement but it doesn't return anything.

we use this so that we can access instance variables that are hidden (or shadowed) by local variables.
   class Student{
   	 int id;
	 String name;
	 void updateProfile(int newID, String name){
	      id = newId;
	      this.name = name;
	      }
}

we use this.name in the updateProfile() method because one of the method parameters is called name which happens to be one of the instance variables of the Class. So anytime you are in the method and you use name, you are referring to the parameter name. You'd have to use this.name in order to get the instance variable.
Static methods are class methods so they can not use the this reference as this reference is used to access variables and instance methods only.

You can run a class from a different file in another as Java will automatically search and compile the file with the right class. You do not need to compile both files.

Reassigning Object References
By default Java passes by reference. See the ReassignObjectReferences.java file. Any object in memory left without reference will be freed up by Java's garbage collection

Operator
	A symbol which performs an operation on its operands and produces a result.
Unary operator - operates on one operand eg -x, x++;
Binary operator - operates on two operands. placed between operands (infix)
Ternary operator uses two symbols a ? and a : eg (x > 3)? x : 0

Arithmetic Operators
+ addition eg int i = 5 + 2; (+ can also be used to concatenate strings)
- subtraction
Note that both + and - can be used as unary operators eg -x or +x
* multiplication
/ division
% modulus - returns the remainder
++ increment - post-increment (x++) and pre-increment (--x);
-- decrement - post-decrement (x--) or pre-decrement (--x);

Arithmetic operators apply to all primitive types except boolean.
Compound arithmetic assignment x = x + 5 => x += 5; others include -=, *=, /=, %=

Arithmetic Operation Rules
	   Operator precedence rules
	   1. Multiplicative operators (*, /, %) have higher precedence over additive operators.
	   2. Operators in the same level will be evaluated left to right
	   3. Parentheses can be used to change the order of evaluation

Operand Promotion
	Operands smaller than int are promoted to int before addition is applied[byte, short or char]
	eg 127(byte) + 1 (byte) -> 127 (int) + 1 (int) -> 128 (int)
	'a' + 'b' = 195 why? char is treated as a 16 bit unsigned integer
	'a''s decimal value is 97 and 'b' is 98 in UTF-16
	4. Same type operations if both operands are int, long, float or double, then operations are carried in that type and evaluated to a value of that type thus 1 / 2 = 0 not 0.5
	Mixed Type Operations
	If both operands belong to different types, then the smaller type is promoted to larger type (note that long is converted to float even though long is 64 bit and float is 32 bit - float has a greater +).
	Comparison Operators/Relational Operators
	compare one operand with another and test some condition. Since we are testing a condition, the output will be a boolean value. Key for flow control statements
	< lt	<= le  > gt  >= ge	 == eq   != neq
Logical operators/conditional operators
comparison operators alone can only test a single condition eg if(x > 7){..}
How about testing multiple conditions? eg (x > 7) and (y < 2)?

&& AND	  || OR	  ! NOT

With these logical operators we can test one or more conditions. Logical operators just like relational operators will return boolean values.They can be used in control flow statements.

&& and || are short circuit operators because they can quickly evaluate without checking both sides of the expression eg  left operand && right operand -> this will evaluate to false if left operand is false and will not wait to check right operand. It only checks right operand if left is true.
left operand || right operand also evaluates fast without checking if left operand is true.
These two short circuit operators can improve run time performance.
&& prevents NullPointerException by preventing us from accessing an object which is null eg if(s != null && s.getGender() == "male"){...} here the && prevents us from just trying to access the getGender method on a null pointer.
Operator precedence
	 ! then && then ||
	 you can use parentheses to change evaluation order

Bitwise Operators
operate on bits. Operands can be integers or boolean
	Applications - mostly in embedded systems with resource constrained environments where things must be manipulated very efficiently.
	Hash tables eg Java HashMap's hash function
	Compression and encryption
Bitwise Operators
	& returns 1 if both bit inputs are 1
	| returns 1 if either of input bits is 1
	^ returns 1 if only one of the input bits is 1
	~ inverts bits of its operand
	bitwise & and | are non-short circuit operators so they always check both operands unlike in && and ||
	Compound bitwise assignment &=
Bit Shift Operators
    shift bits. Their operands must be integers.
    << left shift
    >>> unsigned right shift
    >> signed right shift [preserves the sign of the original number]
    Uses - faster than multiplication and division and compilers can use them. Used in games and embedded programming. Also systems without floating points.Can also be expressed with compound expressions >>=, >>>= <<=

Control-flow
If body of any of the control statements has more than one statement, use curly braces. Note that it is also good practice to include curly braces anyway
if, for, while, do while, switch

if(x > 7){...}
else if{...}
else {...}

switch(x){
	case a:
	     do ...;
	     break;
	case b:
	     do ...;
	     break;
	default:
		do....;

}

a switch expression's numerical final value SHOULD EVALUATE TO AN INTEGER. Thus items submitted to the switch expression should be converted to integers and then compared.No duplicate values should be placed in the switch expression. Note that the range of the case values should be in the data type range.
Case label value must be a constant expression.Can be an integer or string literal. eg final int = 4;
only constants can be used as cases
                                 in a switch statement, hence the use of fin\
al. This is because the switch statement is setup during compilation so it n\
eeds the final values. A null case cannot be used as well
switch statement cannot be used in the following conditions:
       - there is more than one condition to test
       - tests other than equality eg month >= 3;
       - switch cannot be used for variables that are not integers, strings or enum
       - if at least one of the case label restrictions does not apply.
switch is preferred if:
       - readability improves
       - intent - the switch is clear with what variable is being evaluated
       - switch is faster than if because case labels are known at compile time. Also, switch has less comparisons. In the worst case, an if statement will take O(n) time to evaluate whereas a switch statement is O(1)
Ternary Operator
Can be used as an alternative to an if else statement.
Shorthand for if-else with single statements
	  result = (boolean-expression)? value-if-true : value-if-false;
**Note that parentheses are optional but they improve readability.
When to use ternary operations - to improve code readability
Ternary operator cannot be an expression statement.
 (x > 2)? 3: 4; is invalid. Ternary operator can only be used if we are assigning something. eg int y = (x > 2)? 3:4;

for Statement
To iterate over array elements.
for(int i = 0; i < 10; i++){...}
 Initialization part of for loop can be done on the outside. eg
   	   int i = 0;
	   for(;i<10; i++){...}
for-each Statement
Iterate arrays & other data structures
for(int i: array){
	System.out.println(i);
}
Increments are taken care of internally. Reduces chances of errors in nested loops.
Traditional for loop should be used when you need to transform one item in the index. Also useful when you want to traverse two arrays in parallel.
eg for(int i = 0, j = 0; i < I_array.length && j < J_array.length; i++,j++){
   System.out.println(I_array[i]+ " "+ J_array[j]);
}
Traditional for loops are also good for backward iteration. With for each you can only move forward.
For each has much cleaner cde.
While loop
Run if you do not know the number of times the loop should run
Do while
Runs at least once. Note that the do{...}while(...); expression ends with a semicolon;
Infinite loops
	 while(true){
		if(getTime() == 8){
			     sendEmails();
			     }
			     }
break statement
Exits immediately enclosing swith or loop (for/while). A break statement needs to be in a switch or for/while loop otherwise it will be invalid
Labeled break Statement
How about if you want to exit one of the outer switch/loop. First we label the block statement label: block statement
A block statement contains 0 or more statements enclosed in curly braces eg any control statement with a brace. Once we have labeled a block , we can use the break label; command to break;
continue statement
	 continues with the next iteration of the innermost loop. skips the rest of the loop and goes to the next cycle.
There is also a labeled continue statement. First we label the loop we want then we use continue label. the continue label cannot be used with an if statement though. break can be used with it though.
Variable scope
Every variable has a scope
Entire class variables/globals

Packages and Information Hiding
Java API
Library of well-tested classes. Over 4 000 in Java 8
Packages contain classes
Why do we need packages?
    packages provide meaningful organizaiton of classes
    name scoping
    security

Important packages
	  - java.lang = fundamental classes eg String
	  - java.util = Data structures
	  - java.io = reading & writing
	  - java.net = networking
	  - java.sql = databases
Know and Use the Libraries
API benefits
    - focus on writing new logic
    - good APIs improve performance over time
    - gain new functionality too

Accessing Packages
if classes are on the same package, they usually have direct access
if in a different package,
	 - use import statement
	 - use the fully qualified class name - rare package_name.class_name		even if we wrote the class we may have to use these

import Statement
eg import java.util.ArrayList;

class Fooclass{
      void(){
      ArrayList list = new ArrayList();
}

}

Have to put import statement above the class definition. Here we imported a single class called ArrayList from java.util. This is also called a single type import.
Often we import multiple classes. We can use * import (star import) - import on demand. This imports all classes in a package.
eg. import java.util.*;
Or you can use explicit imports for specific classes.

* import has the problem that it can break your code eg
  import java.util.*;
  import java.sql.*;

  if initially the java.util package has a Date class but next year, the java.sql adds a Date class as well. An explicit import would not have this problem. Explicit imports also add more clarity. Although there is no strict consensus, explicit imports are preferred.

Alternative to using import is to use the fully-qualified class name eg
	    java.util.ArrayList list = new java.util.ArrayList();
This is cumbersome and is only useful if say we want to use java.util.Date & java.sql.Date in the same class. You would need to use at lease one fully qualified class-name or both as shown below.

Solution 1
USE ONLY ONE EXPLICIT IMPORT

    import java.util.Date;
    import java.sql.*;

    Date date; //from util
    java.sql.Date date2;

    here the explicit import always takes precedence over * import in such a scenario. If we had even more packages, we still can only explicitly import one of them.

Solution 2
USE FULLY QUALIFIED NAMES
    import java.util.*;
    import java.sql.*;

    java.util.Date date;
    java.sql.Date date2;

we still have to use only fully qualified names here

NOTE THAT THE FOLLOWING IS NOT ALLOWED:
     import java.util.Date;
     import java.sql.Date;

this is because it is a specific import of an identical class name
An import statement does not make your class bigger and it does not affect the run time performance. It simply saves you from typing the fully-qualified name - the compiler does this during compilation.

java.lang is imported by default- that is why we could use String

Creating our own packages
Packages are directories on the file system.
We need the package statement in the name. Typically package names have at least two or 3 components separated by dots. It must be the first statement above any imports

   eg package bswiswa.package.name;
      import java.util.ArrayList;
      class Basics{
}

To create package
   ensure that a matching directory structure exists
   use package statement
   once class is compiled, the package name is part of the class name

In professional projects, class files and source code are kept separately
This helps in deployment and code distribution.
setup the package statement in the same folder structure
companies use their reversed internet domain names to begin their package na\
mes eg com.precipio.share
Package name may not be valid because of hyphens or other special characters\
. Also if package name begins with a digit or a reserved keyword eg "int". I\
n this case the suggested convention is to add an underscore
eg java_bootcamp.StudentPackage above

When creating a package make sure there is a matching directory structure that matches the name of the package
Then we need to use a package statement at the top of the class.
Once a package statement is placed on top of a class, the package name becomes part of the class name so for example the command to interpret the bytcode java Basics will no longer work for a class Basics with a package statement but you will have to use java bswiswa.javacoding.Basics ie a fully qualified name.
**NOTE THAT you still compile the class using javac Basics.java and the output class is still called Basics.class and not bswiswa.javacoding.Basics.class
To make it work, you may have to change the CLASSPATH to the parent folder of your package so you can run it anywhere. On UNIX you have to use the terminal command: export CLASSPATH=/Users/macbookpro/Documents/java-bootcamp/ for example
NOrmally once the class files are created and we wanted to share the class files externally in the form of a library, we would create a library and we would share the JAR file. The JAR file only has the class files.

Sub-packages
Packages help to meaningfully organize our classes. Sometimes in large projects, a single package can have numerous groups of classes that perform some specialized functions. These groups of classes can be more meaningfully be organized into subpackages eg java.util & java.util.concurrent
import java.util.* only imports classes in the java.util package and not any of the ones from its subpackages.
If you want to import a subpackage, the full subpackage name should be specified so in the example of java.util and java.util.concurrent, if you want to use subpackages in concurrent, you have to explicitly import them

import java.util.*;
import java.util.concurrent.*;

How should we name packages?
Use the organization's reverse internet domain name
    eg edu.stanford.math.geometry vs com.oracle.math.geometry
Component Naming Conventions
	  components in packages should consist of lowercase alphabets, rarely digits
	  should be short, less than 8 characters
	  should have meaningful abbreviations eg util for utilities
	  acronyms are fine eg awt for Abstract Window Toolkit
	  generally a component should be a single word
	  Never start with java or javax as these words are used with the standard java API.

Note on ClassPaths
If classpath is set, java interpreter would scan each of the paths in classpath to run the program specified on the command line. javac command, on the other hand, will not rely on the classpath to compile the program specified on the command line. It will always try to compile the program specified on the command line by looking for that program in the same directory where the javac command is being executed, i.e., if the command is javac HelloWorld.java, then if HelloWorld.java is available in the same directory where this command is executed, then HelloWorld.class will be generated. This is however not the case with java interpreter, which always uses classpath to find the .class file specifed on the command line. 

For all non-JDK classes that are accessed from the program specified on command line, both javac & java will rely on paths in the classpath. 

Note that classpath can also be set temporarily while running a javac or java command in the following way. The option -cp is followed by the path (C:\java). Instead of -cp, -classpath can also be used. Note that path can also be simply dot (.) indicating current directory. However, if you want to set classpath permanently, then you should set it as environment variable.

javac -cp C:\java Hello.java

java -cp C:\java Hello

Finally, recall that javac will always try to automatically compile any source files accessed from the program specified on the command prompt. If the .class files have already been generated for those files, then javac will still recompile those source files that have a later timestamp than the corresponding .class files, i.e., they have been modified after the .class files were generated.

Strings
String manipulation is one of the most common operations in programming. If you do not have a good understanding of Strings you can write very inefficient code
String class is part of java.lang.String package

String s = new String(); //empty string
String s = new String("hello") // a string is enclosed in double quotes (character literals are in single quotes 'c'.
string literal is a string object. Internally it is passed as an object;
So in the initialization String s = new String"hello!");
s is an object reference to a string object and we are creating by passing another object reference as input to the constructor.

also we can do char cArray[] = { 'h', 'e', 'l', 'l', 'o'};
     	       String s = new String(cArray);

or the recommended way String s = "hello!"; here, hello is still a string object reference;
Internally the string class uses a character array to storre text. A string in Java is basically a sequence of unicode character.
Strings are immutable - once created, the value is never changed. So a string object contains a immutable string of unicode characters.
+  operator can be used for String concatenation
All strings created using string literals are saved in a location called String pool. The pool helps save memory by not duplicating strings.eg two strings with the same text inside. This does not happen with Strings created using the new keyword. If you create two identical strings with the new keyword, then there are duplicates created.

String Manipulation
String class
Comparing
Searching
Examining characters
Extract siblins
Case translation
Replace
Split

3rd Party String Utilities
Apache Commons Lang ~ StringUtils
Guava's String Utility Classes

Be aware that they exist and are commonly used; Research before building a new package
TODO: LOOK AT STRING CLASS API

String Pools
String literals are stored in a special area of the heap memory (where all objects reside) called string pool
Identical String literals share same storage. As long as the strings are created during  a single JVM process.
Strings created via the new keyword are stored as regular objects also on the heap section of memory but not in the string pool. They get their own storage and identical strings do not share storage.
When a String is created as a string literal say String s1 = "Hello"; a string object is created in the string pool and s1 stores the memory location of that object. If another string s2 is created with the same literal eg String s2 = "Hello"; then no new string object is created and s2 points to the same memory location of the previously created "Hello" object. Thus s1 == s2 is true.
If another string reference is created but using the new keyword eg String s3 = new String("Hello"); the identical object is still passed to the constructor String() and so it doesn't create a new String object in the pool since "Hello" is already there. Instead, it creates a string object  outside of the string pool pointing to that string object in the string pool. Then the location of this secondary object is passed back to s3. If another string is created with the new keyword again, String s4 = new String("Hello") another separate object is created outside of the string pool, in heap memory. This object still references the "Hello" in the string pool. The location of this object is assigned to the new object reference s4. Thus s3 == s4 is false 

In general, when a string is created with the new keyword, first if that string doesn't exist in the string pool, then a new string object is created in the string pool, containing the string literal passed into the String constructor. Then outside of the string pool, another string object is created and this one references the one inside of string pool. The memory address of this secondary object is passed back to the String reference object. Thus, two string objects are created on the heap memory in this case.

So the string pool stores a single copy of each string literal as a string object. The string pool only stores string objects. There is only one copy of string pool on the heap. It is also called string table.
The process of building the string pool is called interning. Each string object in the pool is called an intern
When JVM received  a string literal for the first time, it creates a new String object with the given literal. Then it invokes the intern() method . The intern method checks if the string is already in the string pool. If it is there, it returns a reference of that existing object. JVM then abandons the newly created object. If string pool doesn't contain the string, then the string object is added to the string pool and returns its reference.
If the same literal is encountered once again, then JVM checks if the intern method was previously called on such a literal and if so returns its reference. JVM always checks if invoke was previously called on a literal.

When two literals are concatenated, their result is interned as the concatenation produces a literal whose value is known at compile time.
so String s = "hel" + "lo"; ->this expression is interned
   String s1 = "lo"
   String s2 = "hel"+ s1; -> not interned. Here variable s2 is a concatenation between a literal and a variable s1. Here, variable s1 is evaluated at run time and so we do not have a literal for it on compile time so this would not result in the creation of an intern and the resulting object would be outside of the string pool. But we can explicitly invoke the intern method on s2 then an intern would be created. s2 = s2.intern(); explicit interning
Explicit interning is not useful unless we are working with many strings eg Natural language processing.
String Immutability
Once a string is created, its value cannot be changed
String s1 = new String("abcd");
       s1 = new String("1234"); // above object "abcd" is abandoned. The references can be reused which is why we could assign s1 to something else
       Why immutable strings? it would affect string interning as the same string object could alter a shared object leading to serious errors for the other references.
       Also affects concurrency as multiple threads may be sharing the same string.
       Also creates security vulnerabilities by allowing hackers to alter input strings and gaining access to other parts.
       
 String concatenation
+ operator All non-string operands will be converted to String if a string comes first 
  eg String s = "hello"+ 1 + 3 -> "hello13"
  but String s = 1 + 3 + "hello" -> "4hello"
Evaulation always happens from left to right for the + operator. Precedence can be set using parentheses.
StringBuilder & StringBuffer - from java.lang package. These two allow us to mutate their StringBuilder and StringBuffer objects
StringBuilder sb = new StringBuilder();
	      sb.append("hello");
	      sb.append(" world!);
	      String s = sb.append(" Good").append(" morning").toString();

Other methods in StringBuilder: length, delete, insert, reverse, replace
StringBuilder is not synchronized - if the same string builder object is shared between two processes, one process can modify a shared string.

StringBuffer is now obsolete. It is slower than StringBuilder because StringBuffer is synchronized. Its API is compatible with StringBuilder.
BEWARE OF THE PERFORMANCE OF STRING CONCATENATION
The + operator is a convenient way to combine a few strings. It should not be used for many strings because it severely affects performance.
This is because with each concatenation the following steps are taking place:
     1. contents of both strings are copied
     2. a new StringBuilder object is created and appended with both strings
     3. the resulting StringBuilder object is then used to create a new String object via the toString() method. The StringBuilder object is discarded
Thus concatenation is time consuming O(n^2), space consuming
RECOMMENDATION: Use StringBuilder instead. O(N) and orders of magnitude faster than + operator. Also twice as fast as StringBuffer

Escape Sequences
A character preceded by \
To use special characters and strings
\", \', \n, \t, \\, \r (carriage return), \b (backspace), \f (formfeed)
\u0041 UTF character code.
Note that the escape sequence is not required to put the " or ' in a string.

Access Levels and Hiding of Information
Access levels provide restrictions on accessing classes and their members.
eg we may want a class to only be accessed by other classes in the same package. We may not want other external classes to create instances of that class.
In most cases, you'd want the class to be accessible to all classes inside and outside of that package. 
This is done by using the keyword public in the class declaration. public is an access modifier. eg public class Basics{...}. 
If you don't use any default modifier, the package is only available in the package.

Accessibility for Class Members
Inside class - member only accessible within the class that it is defined. For this you use the private access modifier.
Sometimes we want to make a member accessible to other members in the same package, for this we do not use any modifier at all. By default, the members are accessible to all classes in that package but not outside. This is called package-private.
We may also want a class to be accessible to all package members as well as any subclass. Those subclasses may be outside the package too. for this access level, you would use the protected access modifier
Finally we may want members to be accessible to any code regardless of where it is defined - inside or outside package. This is the public access level.
private and public are the most used. protected is rarely used.

Members of a class have additional access restrictions -> private and protected
public and default classes apply to both.

private Access Modifier
private member variables can only be defined at class level. any private member variable created inside a method is already private to that method, so this results in a compile error
 eg private int id; // visible only within the class.  
void method(){	
     private int b; //this causes an error since b is already private to method()
}

You can also make methods private eg private void method() - NOTE THAT THE ACCESS MODIFIER ALWAYS COMES FIRST OTHERWISE YOU WILL GET A COMPILE ERROR

Private MEANS THAT IT IS PRIVATE TO THE CLASS AND NOT PRIVATE TO OBJECTS OF ITS CLASS
eg class Student{
   private int id;
   String name;
}

Student s1 = new Student();
s1.id = 1;
Student s2 = new Student();
Here since s1 and s2 are both of the Student class,  they can access each others'
private member id. Any other class beside Student cannot access the id member eg Lecturer etc...
By using access modifiers we can restrict the parts of the code that can be seen outside of the package.

Information Hiding
WE MUST TRY TO RUN GOOD PROGRAMS RATHER THAN FAST ONES. USE GOOD DESIGN PRINCIPLES FIRST
Encapsulation
A language facility that allows bundling of data and methods that manipulate that data. It is done using a class in Java eg 
  public class Student{
  	 //variables or data
	 public int id;
	 public String name;

	 //method definitions
	 public boolean updateProfile(String newName){
	 	name = newName;
		return true;
	 }
}

Here, the Student class has allowed us to bundle our id and name data

ENCAPSULATION ALONE DOES NOT LEAD TO GOOD DESIGN
eg for the previous example, the variables are all available to the public. This can lead to tight coupling
Tight coupling
      can't enforce invariant (or range)
      eg for a gender field, we cannot restrict the possibilities to "male", "female" and "transgender" since client code can directly access and change the gender field to any value they wish. 
      can't change data representation eg if we want to change one of the variables to a different type, the client code may be affected. We cannot change it without possibly compromising the end user's program. If we have an API for a package, the end user expects that none of the available methods will change for a long time.
      IN PUBLIC CLASSES, USE ACCESSOR METHODS, NOT PUBLIC FIELDS
Accessor methods
	 public class Student {
	 	private String gender;
		public void setGender(String gender){
		       this.gender = gender;
		       }
		public String getGender(){
		       return gender;
		       }
}

1. access modifier for the gender field is set as private
2. we define a public getter (accessor) method eg public String getGender();
3. we define a public setter (mutator) method eg public void setGender();

IDEs try to automatically have you declare getter and setter methods once you declare a private variable in a class.

How do accessor methods help us avoid the problems that come from tight coupling? - now we can enforce invariants by checking the submitted input. if it falls outside of our range, we can reject it and throw exceptions to the client that the argument is illegal. See below:
     public class Student {
      	    private String gender;
	    public void setGender(String gender){
	    	   if(gender.equals("male") || gender.equals("female") || gender.equals("transgender"){
		   this.gender = gender;	
		   }
		   else{
		   throw new IllegalArgumentException("Wrong gender passed!!");
		   }
		    }	
	public String getGender(){
	       return gender;   						
	       }
} 

We can also change our own internal representations and leave our implementations without affecting the clients. The code is now loosely coupled. API is the same and there is no access to the backend of the API.

Loosely Coupled Systems 
	allow us to develop, test, use and optimize in isolation
	useful code in multiple projects and decreases risk of building large projects.

MINIMIZE THE ACCESSIBILITY OF CLASSES AND MEMBERS
General suggestion is:
1. carefully design a minimal public API of your class. 
2. See which of the members will really be needed by client and make them public 
3. Make all the others private
4. Make a member default only if really needed
[frequent changes mean you need to reexamine your design!]

Accessibility for classes/interfaces
If possible let it be default. If only one other class uses it, consider making it a private nested class
